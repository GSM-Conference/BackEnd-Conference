# Dispatcher-Servlet(디스패처 서블릿)

* 디스패처 서블릿이란 HTTP 프로토콜로 들어오는 모든 요청을 가장 먼저 받아 적합한 컨트롤러에 위임해주는 프론트 컨트롤러(Front Controller)라고 정의할 수 있다.

> 서블릿이란 클라이언트의 요청을 처리하고, 그 결과를 반환하는 웹 프로그래밍 기술이다.

클라이언트로부터 요청이 오면 서블릿 컨테이너(Tomcat ..)가 요청을 받는다.

그리고 이 모든 요청들을 디스패처 서블릿이 가장 먼저 받는다.
* 여기서 디스패처 서블릿을 프론트 컨트롤러라고 부른다.
  * 프론트 컨트롤러는 보통 서블릿 컨테이너의 제일 앞단에서 서버에 들어오는 클라이언트의 요청을 처리하는 컨트롤러이다. MVC패턴에서 주로 사용된다.

## Dispatcher-Servlet 장점

* 과거에는 모든 서블릿을 URL 매핑을 위해 `web.xml`에 모두 등록해야했지만, 디스패처 서블릿이 해당 애플리케이션으로 들어오는 모든 요청을 핸들링해주고 공통 작업을 처리하면서 편리하게 이용할 수 있었다.
* 우리가 컨트롤러를 구현하기만 하면 디스패처 서블릿이 적합한 컨트롤러로 위임해준다.

## 정적 자원(Static Resources)의 처리

* 디스패처 서블릿의 문제점이 있다. 필요없는 HTML, CSS, JAVASCRIPT 같은 정적 파일에 대한 요청까지 모두 가로채는 것이다. 이 문제를 해결하기 위해 해결법 2개를 고안했다.
  * 정적 자원 요청과 애플리케이션 요청을 분리
  * 애플리케이션 요청을 탐색하고 없으면 정적 자원 요청으로 처리

#### 정적 자원 요청과 애플리케이션 요청을 분리

* /apps URL로 접근하면 디스패처 서블릿이 담당한다.
* /resources URL로 접근하면 담당하지 않는다.

그러나 코드가 지저분해지고 모든 요청에 저 URL을 붙여야하기 때문에 좋은 설계방식이 아니다.

#### 애플리케이션 요청을 탐색하고 없으면 정적 자원 요청으로 처리

* 디스패처 서블릿이 요청할 컨트롤러를 먼저 찾고, 요청에 대한 컨트롤러를 찾을 수 없으면, 2차적으로 설정된 자원 경로를 탐색하여 자원을 탐색한다.
* 이 방식을 사용하면 효율적인 리소스 관리를 할 수 있고, 확장에 용이하다.

## 디스패처 서블릿 동작과정

![img](https://img1.daumcdn.net/thumb/R1280x0/?scode=mtistory2&fname=https%3A%2F%2Fblog.kakaocdn.net%2Fdn%2FbImFbg%2FbtrGzZMTuu2%2FCkY4MiKvl5ivUJPoc5I3zk%2Fimg.png)

1. 클라이언트의 요청을 디스패치 서블렛이 받는다.
   * ![img](https://img1.daumcdn.net/thumb/R1280x0/?scode=mtistory2&fname=https%3A%2F%2Fblog.kakaocdn.net%2Fdn%2FoN96r%2Fbtrw7SYEpgr%2FlKLp5nqEZUJR32GoPc9bwk%2Fimg.png)
   * 실제로 Interceptor가 Controller로 요청을 위임하지는 않는다. 그저 처리 순서를 도식화한 것이다.
2. 요청 정보를 통해 요청을 위임할 컨트롤러를 찾는다.
   * 디스패처 서블릿은 요청 정보를 바탕으로, 요청을 처리할 컨트롤러를 찾고 해당 메소드를 호출해야 한다.
3. 요청을 컨트롤러로 위임할 핸들러 어댑터를 찾아서 전달한다.
   * 디스패처 서블릿은 컨트롤러로 요청을 직접 위임하는 것이 아니라 HandlerAdapter를 통해 어댑터 패턴을 적용해 컨트롤러로 요청을 위임한다.
4. 핸들러 어댑터가 컨트롤러로 요청을 위임한다.
   * 핸들러 어댑터가 컨트롤러로 요청을 넘기기 전에 공통적인 전처리 과정이 필요하다.
   * 요청에 매칭되는 인터셉터들도 실행을 시키고, `@RequestParam`, `@RequestBody` 등으로 파라미터를 준비하는 ArgumentResolver도 실행하는 등의 다양한 작업을 수행한다.
5. 비지니스 로직을 처리한다.
   * 이후에 컨트롤러가 서비스를 호출해 비지니스 로직이 진행된다.
6. 컨트롤러가 반환값을 반환한다.
   * 비지니스 로직이 처리된 후 컨트롤러가 반환값을 반환한다.
7. 핸들러 어댑터가 반환값을 처리한다.
   * 핸들러 어댑터는 컨트롤러로부터 받은 반환값을 응답 처리기인 `ReturnValueHandler`가 후처리한 후에 디스패처 서블릿으로 돌려준다.
8. 서버의 응답을 클라이언트로 반환한다.
   * 디스패처 서블릿을 통해 반환되는 응답은 다시 필터들을 거쳐 클라이언트에게 반환된다.